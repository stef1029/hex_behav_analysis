from matplotlib import pyplot as plt
from pathlib import Path
import numpy as np
from datetime import datetime
import matplotlib.cm as cm
import re

from hex_behav_analysis.utils.Cohort_folder import Cohort_folder
from hex_behav_analysis.utils.Session_nwb import Session
from matplotlib import pyplot as plt
from pathlib import Path
import numpy as np
from datetime import datetime
import matplotlib.cm as cm
import re

from hex_behav_analysis.utils.Cohort_folder import Cohort_folder
from hex_behav_analysis.utils.Session_nwb import Session

# Define colour scheme
COLOUR_SCHEME = {
    "all_trials": (0, 0.68, 0.94),
    "visual_trials": (0.93, 0, 0.55),
    "audio_trials": (1, 0.59, 0)
}


def lighten_colour(colour, factor=0.5):
    """
    Lighten a colour by blending it with white.
    
    Parameters
    ----------
    colour : tuple
        RGB colour tuple with values between 0 and 1
    factor : float
        Lightening factor between 0 and 1
        
    Returns
    -------
    tuple
        Lightened RGB colour tuple
    """
    return tuple(min(1, c + (1 - c) * factor) for c in colour)


def plot_cue_angle_distribution(
    sessions_input,
    plot_title=None,
    angle_type='cue_angle',
    bin_mode='manual',
    num_bins=12,
    trials_per_bin=10,
    normalise=False,
    cue_modes=('all_trials',),
    plot_individual_mice=False,
    exclusion_mice=(),
    output_path=None,
    plot_save_name='angle_distribution',
    draft=True,
    likelihood_threshold=0.6,
    min_trial_duration=None,
    bar_width_factor=0.8,
    verbose=True,
):
    """
    Plot radial histogram of cue-presentation angles, mouse-bearing angles, or LED positions.
    
    Combines data from all sessions and mice unless otherwise specified. For mouse bearing plots,
    angles are standardised across rigs so that a mouse facing port 1 always appears at 0°
    regardless of the actual camera orientation in each rig.

    Parameters
    ----------
    sessions_input : list[Session] | dict[str, list[Session]]
        Session objects or a mapping name → sessions
    plot_title : str | None
        Plot title; autogenerated if None
    angle_type : {'cue_angle', 'mouse_bearing', 'led_position'}
        Cue‐presentation angle (−180→180 deg), mouse bearing (0→360 deg, standardised across rigs), 
        or LED position (6 discrete positions at standard angles)
    bin_mode : {'manual', 'rice', 'tpb'}
        Manual number of bins, Rice rule, or trials-per-bin
        (ignored when angle_type='led_position')
    num_bins : int
        Manual number of bins (bin_mode='manual')
        (ignored when angle_type='led_position')
    trials_per_bin : int
        Target trials per bin (bin_mode='tpb')
        (ignored when angle_type='led_position')
    normalise : bool
        Plot proportions instead of counts
    cue_modes : tuple[str, ...]
        ('all_trials', 'visual_trials', 'audio_trials') any subset
    plot_individual_mice : bool
        Overlay per-mouse profiles
    exclusion_mice : tuple[str, ...]
        Mice to omit
    output_path : pathlib.Path | None
        Directory to save *.svg/*.png (created if missing)
    plot_save_name : str
        Base filename
    draft : bool
        If True, timestamped filenames; else 'final_*'
    likelihood_threshold : float
        Ear-tracking likelihood minimum
    min_trial_duration : float | None
        Minimum trial duration (s) to keep
    bar_width_factor : float
        Fractional bar width (0–1)
    verbose : bool
        Print diagnostic information about data collection
        
    Notes
    -----
    For mouse bearing plots, the function automatically compensates for different camera orientations
    across rigs by using the port_angles attribute of each session. This ensures that bearings are
    comparable across rigs (e.g., a mouse facing port 1 always appears at 0° on the plot).
    
    For LED position plots, ports are always displayed at standard positions (0°, 60°, 120°, 180°, 
    240°, 300°) regardless of the actual camera orientation in each rig.
    """
    # Determine angle limits and range
    if angle_type == 'cue_angle':
        limits = (-180.0, 180.0)
    elif angle_type == 'mouse_bearing':
        limits = (0.0, 360.0)
    elif angle_type == 'led_position':
        limits = (0.0, 360.0)
        # LED positions are fixed at 6 standard points
        led_positions_deg = np.array([0, 60, 120, 180, 240, 300])
    else:
        raise ValueError("angle_type must be 'cue_angle', 'mouse_bearing', or 'led_position'")

    if plot_title is None:
        if angle_type == 'cue_angle':
            plot_title = 'Cue Presentation Angle Distribution'
        elif angle_type == 'mouse_bearing':
            plot_title = 'Mouse Bearing Angle Distribution'
        else:  # led_position
            plot_title = 'LED Position Distribution'

    angle_span = limits[1] - limits[0]

    # Helper function to get colours for multiple datasets
    def _get_colours(n_sets):
        """Get colour palette for n datasets."""
        if n_sets <= 3:
            base = [COLOUR_SCHEME['all_trials'], 
                    COLOUR_SCHEME['visual_trials'], 
                    COLOUR_SCHEME['audio_trials']]
            return base[:n_sets]
        cmap = plt.cm.get_cmap('viridis', n_sets)
        return [cmap(i) for i in range(n_sets)]

    # Normalise session input format
    if isinstance(sessions_input, dict):
        if cue_modes != ('all_trials',):
            raise ValueError("When sessions_input is a dict, cue_modes must be ('all_trials',).")
        sessions_dict = sessions_input
    else:
        sessions_dict = {'Data': sessions_input}

    colours_list = _get_colours(len(sessions_dict))

    # Collect trials from all sessions
    def _collect_all_trials(session_list):
        """
        Collect trials from all sessions, organised by mouse and cue mode.
        
        Returns all trials combined, organised by cue mode, per-mouse data, and rig information.
        """
        all_trials_by_mode = {mode: [] for mode in cue_modes}
        trials_by_mouse_and_mode = {}
        excluded = dict(catch=0, too_quick=0, no_turn_data=0, low_likelihood=0)
        
        session_count = 0
        mouse_session_counts = {}
        rig_angles = {}  # Store port angles for each rig
        
        for session in session_list:
            session_count += 1
            mouse_id = session.session_dict.get('mouse_id', 'unknown')
            
            # Track sessions per mouse
            mouse_session_counts[mouse_id] = mouse_session_counts.get(mouse_id, 0) + 1
            
            # Store rig port angles if available
            if hasattr(session, 'rig_id') and hasattr(session, 'port_angles'):
                rig_angles[session.rig_id] = session.port_angles
            
            if mouse_id in exclusion_mice:
                continue
                
            # Initialise mouse data structure if needed
            if mouse_id not in trials_by_mouse_and_mode:
                trials_by_mouse_and_mode[mouse_id] = {mode: [] for mode in cue_modes}
            
            # Process each trial
            for trial in session.trials:
                # Store session reference in trial for later access to rig info
                trial['_session'] = session
                
                # Apply exclusion criteria
                if trial.get('catch'):
                    excluded['catch'] += 1
                    continue
                    
                if angle_type != 'led_position' and trial.get('turn_data') is None:
                    excluded['no_turn_data'] += 1
                    continue
                    
                # Check ear tracking likelihood (not needed for LED position)
                if angle_type != 'led_position':
                    turn_data = trial['turn_data']
                    if (turn_data.get('left_ear_likelihood', 1.0) < likelihood_threshold or
                        turn_data.get('right_ear_likelihood', 1.0) < likelihood_threshold):
                        excluded['low_likelihood'] += 1
                        continue
                    
                # Check trial duration if specified
                if min_trial_duration is not None:
                    cue_start = trial.get('cue_start')
                    sensor_start = trial.get('next_sensor', {}).get('sensor_start')
                    if cue_start is not None and sensor_start is not None:
                        if sensor_start - cue_start < min_trial_duration:
                            excluded['too_quick'] += 1
                            continue
                
                # Categorise trial by cue mode
                if 'all_trials' in cue_modes:
                    all_trials_by_mode['all_trials'].append(trial)
                    trials_by_mouse_and_mode[mouse_id]['all_trials'].append(trial)
                
                correct_port = trial.get('correct_port', '')
                if 'visual_trials' in cue_modes and 'audio' not in correct_port:
                    all_trials_by_mode['visual_trials'].append(trial)
                    trials_by_mouse_and_mode[mouse_id]['visual_trials'].append(trial)
                
                if 'audio_trials' in cue_modes and 'audio' in correct_port:
                    all_trials_by_mode['audio_trials'].append(trial)
                    trials_by_mouse_and_mode[mouse_id]['audio_trials'].append(trial)
        
        if verbose:
            print(f"\nData collection summary:")
            print(f"  Total sessions processed: {session_count}")
            print(f"  Mice found: {list(mouse_session_counts.keys())}")
            print(f"  Sessions per mouse: {mouse_session_counts}")
            print(f"  Rigs found: {list(rig_angles.keys())}")
            print(f"  Port angles by rig: {rig_angles}")
            print(f"  Excluded trials: {excluded}")
            print(f"  Total included trials by mode:")
            for mode in cue_modes:
                print(f"    {mode}: {len(all_trials_by_mode[mode])}")
        
        return all_trials_by_mode, trials_by_mouse_and_mode, excluded, rig_angles

    # Create figure
    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw={'polar': True})
    all_hist_values = []

    # Process each dataset
    for dataset_idx, (dataset_name, sessions) in enumerate(sessions_dict.items()):
        if verbose:
            print(f"\nProcessing dataset: {dataset_name}")
            
        # Collect all trials from all sessions
        all_trials_by_mode, trials_by_mouse_and_mode, excluded, rig_angles = _collect_all_trials(sessions)
        
        # Calculate number of bins and bin edges
        if angle_type == 'led_position':
            # For LED positions, use 6 fixed bins
            n_bins = 6
            bin_size = 60.0
            # Create bins centred on LED positions
            bin_edges = []
            for pos in led_positions_deg:
                bin_edges.append((pos - 30) % 360)
            bin_edges.append(330)  # Close the last bin
            bin_edges = np.array(sorted(bin_edges))
        else:
            # Original binning logic for other angle types
            total_trial_count = sum(len(all_trials_by_mode[mode]) for mode in cue_modes)
            
            if bin_mode == 'manual':
                n_bins = num_bins
            elif bin_mode == 'rice':
                n_bins = int(2 * total_trial_count ** (1.0 / 3.0))
            elif bin_mode == 'tpb':
                n_bins = max(1, int(total_trial_count / trials_per_bin))
            else:
                raise ValueError('bin_mode must be "manual", "rice", or "tpb"')
            
            bin_size = angle_span / n_bins
            bin_edges = np.arange(limits[0], limits[1] + bin_size, bin_size)
        
        # Process each cue mode
        for mode_idx, cue_mode in enumerate(cue_modes):
            # Extract angles from all trials for this mode
            angles = []
            for trial in all_trials_by_mode[cue_mode]:
                if angle_type == 'cue_angle':
                    angle = float(trial['turn_data']['cue_presentation_angle'])
                elif angle_type == 'mouse_bearing':
                    # Get raw bearing angle
                    raw_bearing = float(trial['turn_data']['bearing']) % 360.0
                    
                    # Apply rig-specific rotation to standardise bearings
                    session = trial.get('_session')
                    if session and hasattr(session, 'rig_id') and hasattr(session, 'port_angles'):
                        # Calculate rotation offset: difference between actual port 1 angle and ideal 0°
                        port1_angle = session.port_angles[0] % 360
                        rotation_offset = port1_angle
                        
                        # Apply rotation to standardise bearing
                        # Subtract offset to align port 1 to 0°
                        angle = (raw_bearing - rotation_offset) % 360.0
                    else:
                        angle = raw_bearing
                else:  # led_position
                    # For LED positions, we want to show which port was activated
                    # Always display ports at standard positions (0, 60, 120, 180, 240, 300)
                    port_idx = None
                    
                    # Debug: print available fields in first trial
                    if verbose and len(angles) == 0:
                        print(f"\n  Debug - Trial keys: {list(trial.keys())[:10]}...")  # First 10 keys
                        if 'correct_port' in trial:
                            print(f"  Debug - correct_port value: '{trial['correct_port']}'")
                            print(f"  Debug - correct_port type: {type(trial['correct_port'])}")
                    
                    # Extract port index from correct_port field
                    if 'correct_port' in trial and trial['correct_port'] is not None:
                        port_str = str(trial['correct_port']).strip()
                        
                        # Debug first few
                        if verbose and len(angles) < 3:
                            print(f"  Debug - Processing correct_port: '{port_str}'")
                        
                        # Try different parsing approaches
                        # Look for any digit in the string
                        import re
                        matches = re.findall(r'\d+', port_str)
                        if matches:
                            # Take the last digit found (in case of "audio_port_3" format)
                            port_num = int(matches[-1])
                            port_idx = port_num - 1  # Convert to 0-based index
                            
                            if verbose and len(angles) < 3:
                                print(f"  Debug - Extracted port {port_num} (index {port_idx}) from '{port_str}'")
                    
                    if port_idx is not None and 0 <= port_idx <= 5:
                        # Map port index to standard angle position
                        standard_port_angles = [0, 60, 120, 180, 240, 300]
                        angle = standard_port_angles[port_idx]
                    else:
                        if verbose and len(angles) < 3:
                            print(f"  Debug - Failed to extract valid port index from trial")
                        continue  # Skip if we can't determine port
                        
                angles.append(angle)
            
            if verbose:
                print(f"\n  {cue_mode}: {len(angles)} angles extracted")
            
            # Compute histogram
            if angle_type == 'led_position':
                # For LED positions, count trials at each discrete position
                hist_counts = np.zeros(6)
                for angle in angles:
                    # Find nearest LED position
                    led_idx = np.argmin(np.abs(led_positions_deg - angle))
                    hist_counts[led_idx] += 1
            else:
                hist_counts, _ = np.histogram(angles, bins=bin_edges)
            
            if normalise and hist_counts.sum() > 0:
                hist_counts = hist_counts.astype(float) / hist_counts.sum()
            
            all_hist_values.extend(hist_counts)
            
            # Calculate bin centres for plotting
            if angle_type == 'led_position':
                bin_centres_deg = led_positions_deg
                bin_centres_rad = np.radians(bin_centres_deg)
                width_rad = np.radians(30 * bar_width_factor)  # Fixed width for LED positions
            else:
                bin_centres_deg = bin_edges[:-1] + bin_size / 2.0
                bin_centres_rad = np.radians(bin_centres_deg)
                width_rad = np.radians(bin_size * bar_width_factor)
                
                # Adjust for polar plot if using cue angles
                if angle_type == 'cue_angle':
                    bin_centres_rad = np.where(bin_centres_rad < 0.0, 
                                              bin_centres_rad + 2.0 * np.pi, 
                                              bin_centres_rad)
            
            # Plot main histogram
            colour = (colours_list[dataset_idx] if len(sessions_dict) > 1 
                     else COLOUR_SCHEME.get(cue_mode, (0.5, 0.5, 0.5)))
            label = f'{dataset_name} – {cue_mode}' if len(sessions_dict) > 1 else cue_mode
            
            ax.bar(bin_centres_rad, hist_counts, width=width_rad, 
                   color=colour, alpha=0.7, label=label)
            
            # Overlay individual mouse data if requested
            if plot_individual_mice and trials_by_mouse_and_mode:
                n_mice = len(trials_by_mouse_and_mode)
                mouse_colours = plt.cm.rainbow(np.linspace(0, 1, n_mice))
                
                for mouse_idx, (mouse_id, mouse_data) in enumerate(trials_by_mouse_and_mode.items()):
                    # Extract angles for this mouse and mode
                    mouse_angles = []
                    for trial in mouse_data[cue_mode]:
                        if angle_type == 'cue_angle':
                            angle = float(trial['turn_data']['cue_presentation_angle'])
                        elif angle_type == 'mouse_bearing':
                            # Get raw bearing angle
                            raw_bearing = float(trial['turn_data']['bearing']) % 360.0
                            
                            # Apply rig-specific rotation to standardise bearings
                            session = trial.get('_session')
                            if session and hasattr(session, 'rig_id') and hasattr(session, 'port_angles'):
                                # Calculate rotation offset
                                port1_angle = session.port_angles[0] % 360
                                rotation_offset = port1_angle
                                
                                # Apply rotation to standardise bearing
                                angle = (raw_bearing - rotation_offset) % 360.0
                            else:
                                angle = raw_bearing
                        else:  # led_position
                            # Same logic as main extraction
                            port_idx = None
                            
                            if 'correct_port' in trial and trial['correct_port'] is not None:
                                port_str = str(trial['correct_port']).strip()
                                
                                # Look for any digit in the string
                                import re
                                matches = re.findall(r'\d+', port_str)
                                if matches:
                                    port_num = int(matches[-1])
                                    port_idx = port_num - 1
                            
                            if port_idx is not None and 0 <= port_idx <= 5:
                                standard_port_angles = [0, 60, 120, 180, 240, 300]
                                angle = standard_port_angles[port_idx]
                            else:
                                continue
                                
                        mouse_angles.append(angle)
                    
                    if mouse_angles:
                        # Compute histogram for this mouse
                        if angle_type == 'led_position':
                            mouse_hist = np.zeros(6)
                            for angle in mouse_angles:
                                led_idx = np.argmin(np.abs(led_positions_deg - angle))
                                mouse_hist[led_idx] += 1
                        else:
                            mouse_hist, _ = np.histogram(mouse_angles, bins=bin_edges)
                            
                        if normalise and mouse_hist.sum() > 0:
                            mouse_hist = mouse_hist.astype(float) / mouse_hist.sum()
                        
                        # Plot as line with markers
                        ax.plot(bin_centres_rad, mouse_hist,
                               marker='o', linestyle='-', markersize=4, linewidth=1,
                               alpha=0.8, color=mouse_colours[mouse_idx],
                               label=f'Mouse {mouse_id} (n={len(mouse_angles)})')

    # Configure plot aesthetics
    ax.set_title(plot_title, pad=20)
    ax.legend(loc='upper right', bbox_to_anchor=(1.15, 1.05), fontsize='small')
    
    # Set radial limits
    if all_hist_values:
        ymax = max(all_hist_values) * 1.2
    else:
        ymax = 1.0
    ax.set_ylim(0, ymax)
    
    # Configure angular properties
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(1)  # clockwise
    ax.set_xlim(0, 2.0 * np.pi)
    
    # Set tick labels
    if angle_type == 'cue_angle':
        tick_degrees = np.arange(-180, 181, 30)
        tick_radians = np.where(tick_degrees < 0,
                               np.radians(tick_degrees) + 2.0 * np.pi,
                               np.radians(tick_degrees))
    elif angle_type == 'led_position':
        # For LED positions, show ticks at LED locations
        tick_degrees = led_positions_deg
        tick_radians = np.radians(tick_degrees)
    else:  # mouse_bearing
        tick_degrees = np.arange(0, 361, 30)
        tick_radians = np.radians(tick_degrees)
    
    ax.set_xticks(tick_radians)
    ax.set_xticklabels([f'{int(d)}°' for d in tick_degrees])
    ax.grid(True, alpha=0.3)
    
    # Add radial axis label
    ax.set_ylabel('Count' if not normalise else 'Proportion', labelpad=30)
    
    # Save figure if requested
    if output_path is not None:
        output_path.mkdir(parents=True, exist_ok=True)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S') if draft else 'final'
        if angle_type == 'cue_angle':
            angle_suffix = 'cue'
        elif angle_type == 'mouse_bearing':
            angle_suffix = 'bearing'
        else:
            angle_suffix = 'led'
        modes_suffix = '_'.join(cue_modes)
        base_filename = f"{timestamp}_{plot_save_name}_{angle_suffix}_{modes_suffix}"
        
        for extension in ('svg', 'png'):
            filepath = output_path / f'{base_filename}.{extension}'
            counter = 0
            while filepath.exists():
                counter += 1
                filepath = output_path / f'{base_filename}_{counter}.{extension}'
            plt.savefig(filepath, format=extension, bbox_inches='tight', transparent=True)
            if verbose:
                print(f"\nSaved plot to: {filepath}")
    
    plt.show()


# Example usage
if __name__ == "__main__":
    # Example of how to use the function
    from hex_behav_analysis.utils.Cohort_folder import Cohort_folder
    from hex_behav_analysis.utils.Session_nwb import Session
    
    # Load your sessions
    cohort_dir = "/path/to/your/cohort"
    cohort = Cohort_folder(cohort_dir, use_existing_cohort_info=True)
    
    # Get sessions - this will combine ALL sessions from ALL mice
    sessions = [Session(session_dict) for session_dict in cohort.sessions]
    
    # Plot cue angle distribution for all sessions combined
    plot_cue_angle_distribution(
        sessions_input=sessions,
        angle_type='cue_angle',  # or 'mouse_bearing' or 'led_position'
        num_bins=24,  # 15-degree bins (ignored for led_position)
        normalise=False,  # Show counts
        plot_individual_mice=True,  # Overlay individual mouse data
        cue_modes=('all_trials', 'visual_trials', 'audio_trials'),
        output_path=Path('./figures'),
        plot_save_name='combined_angle_distribution',
        draft=True,
        verbose=True  # Print diagnostic information
    )
    
    # Example: Plot LED position distribution
    # Ports will always be shown at standard positions (0°, 60°, 120°, etc.)
    plot_cue_angle_distribution(
        sessions_input=sessions,
        angle_type='led_position',  # Shows 6 discrete LED positions
        normalise=True,  # Show as proportions
        plot_individual_mice=False,
        cue_modes=('all_trials',),
        verbose=True
    )
    
    # Example: Plot mouse bearing distribution with normalisation
    # Bearings are automatically standardised so port 1 is always at 0°
    plot_cue_angle_distribution(
        sessions_input=sessions,
        angle_type='mouse_bearing',
        num_bins=24,
        normalise=True,  # Show as proportions
        plot_individual_mice=False,  # Don't overlay individual mice
        cue_modes=('all_trials',),
        verbose=True
    )