#!/usr/bin/env python3
"""
DeepLabCut Cleanup Script

This script finds and optionally deletes files generated by the DeepLabCut pipeline
in a given cohort folder structure. It can be run in test mode to preview which files
would be deleted without actually removing anything.

Usage:
    python dlc_cleanup.py /path/to/cohort/folder --test
    python dlc_cleanup.py /path/to/cohort/folder --delete
"""

import os
import re
import argparse
from pathlib import Path


def find_dlc_files(cohort_path, patterns=None):
    """
    Find all DeepLabCut output files in the cohort directory structure.
    
    Args:
        cohort_path (str): Path to the cohort folder containing session folders
        patterns (list): Optional list of regex patterns to match DLC files
        
    Returns:
        list: List of file paths matching DLC output patterns
    """
    if patterns is None:
        # Default patterns for DeepLabCut output files
        patterns = [
            r'.*DLC_resnet\d+.*\.csv$',
            r'.*DLC_resnet\d+.*\.h5$',
            r'.*DLC_resnet\d+.*_meta\.pickle$',
            r'.*DLC_mobilenet.*\.csv$',
            r'.*DLC_mobilenet.*\.h5$',
            r'.*DLC_mobilenet.*_meta\.pickle$',
            # Add more patterns if needed for different model types
        ]
    
    # Compile the regex patterns
    compiled_patterns = [re.compile(pattern) for pattern in patterns]
    
    # List to hold matching files
    matching_files = []
    
    # Walk through the directory structure
    for root, _, files in os.walk(cohort_path):
        for file in files:
            file_path = os.path.join(root, file)
            # Check if file matches any of our patterns
            if any(pattern.match(file) for pattern in compiled_patterns):
                matching_files.append(file_path)
    
    return matching_files


def delete_files(file_list):
    """
    Delete the specified files.
    
    Args:
        file_list (list): List of file paths to delete
        
    Returns:
        tuple: (count of successfully deleted files, list of files that couldn't be deleted)
    """
    deleted_count = 0
    failed_files = []
    
    for file_path in file_list:
        try:
            os.remove(file_path)
            deleted_count += 1
        except Exception as e:
            failed_files.append((file_path, str(e)))
    
    return deleted_count, failed_files


def main():
    """Main function to parse arguments and run the script."""
    parser = argparse.ArgumentParser(description='Clean up DeepLabCut output files from a cohort directory.')
    parser.add_argument('cohort_path', type=str, help='Path to the cohort folder')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--test', action='store_true', help='Test mode: print files that would be deleted')
    group.add_argument('--delete', action='store_true', help='Delete the identified files')
    
    args = parser.parse_args()
    
    # Ensure the cohort path exists
    if not os.path.isdir(args.cohort_path):
        print(f"Error: The specified path '{args.cohort_path}' does not exist or is not a directory.")
        return 1
    
    # Find all DLC files
    dlc_files = find_dlc_files(args.cohort_path)
    
    if args.test:
        # Test mode - just print the files
        print(f"Found {len(dlc_files)} DeepLabCut output files that would be deleted:")
        for file_path in dlc_files:
            print(f"  {file_path}")
        print("\nTo delete these files, run the script with --delete instead of --test")
    
    elif args.delete:
        # Delete mode - remove the files
        if not dlc_files:
            print("No DeepLabCut output files found to delete.")
            return 0
        
        print(f"Deleting {len(dlc_files)} DeepLabCut output files...")
        deleted_count, failed_files = delete_files(dlc_files)
        
        print(f"Successfully deleted {deleted_count} files.")
        
        if failed_files:
            print(f"\nFailed to delete {len(failed_files)} files:")
            for file_path, error in failed_files:
                print(f"  {file_path}: {error}")
    
    return 0


if __name__ == "__main__":
    exit(main())